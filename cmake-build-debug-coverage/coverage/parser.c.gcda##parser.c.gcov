        -:    0:Source:/home/nikolay/it/sch21/github/SmartCalc_v1.0/src/parser.c
        -:    0:Graph:/home/nikolay/it/sch21/github/SmartCalc_v1.0/cmake-build-debug-coverage/CMakeFiles/SmartCalc_v1_0.dir/src/parser.c.gcno
        -:    0:Data:/home/nikolay/it/sch21/github/SmartCalc_v1.0/cmake-build-debug-coverage/CMakeFiles/SmartCalc_v1_0.dir/src/parser.c.gcda
        -:    0:Runs:1
        -:    1://
        -:    2:// Created by nikolay on 1/1/24.
        -:    3://
        -:    4:
        -:    5:// parse string
        -:    6:// and return array of separeted elements
        -:    7:
        -:    8:
        -:    9:#include "smart_calc.h"
        -:   10:#include "string.h"
function isDigit called 5 returned 100% blocks executed 83%
        5:   11:int isDigit(char* ch, parseData* currstr, int* parseidx, int *stringParseindex) {
        5:   12:  if(*ch == '\000') {
        5:   12-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    #####:   13:    return 0;
    %%%%%:   13-block  0
        -:   14:  }
        5:   15:  currstr[*parseidx].lenth = 0;
        5:   16:  if ((*ch >= '0' && *ch <= '9') || *ch == '.') {
        5:   16-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 1
        4:   16-block  1
branch  2 taken 1 (fallthrough)
branch  3 taken 3
        2:   16-block  2
branch  4 taken 0 (fallthrough)
branch  5 taken 2
        3:   17:    char string[300] = {'\0'};
        3:   18:    int flagfloat = 0;
        3:   19:    int idx1 = 0;
        6:   20:    while ((*ch >= '0' && *ch <= '9') || *ch == '.') {
        3:   20-block  0
        6:   20-block  1
branch  0 taken 3 (fallthrough)
branch  1 taken 3
        3:   20-block  2
branch  2 taken 3
branch  3 taken 0 (fallthrough)
        3:   20-block  3
branch  4 taken 0
branch  5 taken 3 (fallthrough)
       3*:   21:      if (*ch == '.') flagfloat = 1;
        3:   21-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    %%%%%:   21-block  1
        3:   22:      string[idx1] = *ch;
        3:   23:      ch++;
        3:   24:      currstr[*parseidx].lenth++;
        3:   25:      idx1++;
        3:   25-block  0
        -:   26:    }
        3:   27:    string[idx1] = '\0';
        3:   28:    if (flagfloat) {
        3:   28-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:   29:      currstr[*parseidx].fval = atof(string);
    #####:   30:      currstr[*parseidx].type = 2;
    %%%%%:   30-block  0
        -:   31:    } else {
        3:   32:      currstr[*parseidx].ldval = atoll(string);
        3:   33:      currstr[*parseidx].type = 1;
        3:   33-block  0
        -:   34:    }
        3:   35:    *stringParseindex += currstr[*parseidx].lenth;
        3:   36:    ++*parseidx ;
        3:   37:    return 1;
        3:   37-block  0
        -:   38:  }
        2:   39:  return 0;
        2:   39-block  0
        -:   40:}
function isFunction called 5 returned 100% blocks executed 48%
        5:   41:int isFunction(char* ch, parseData* currstr, int* parseidx, int * stringParseindex) {
        5:   42:  if(*ch == '\000') {
        5:   42-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 4
        -:   43:
        1:   44:    return 0;
        1:   44-block  0
        -:   45:  }
        4:   46:  currstr[*parseidx].lenth = 0;
        4:   47:  if (*ch == 'c' || *ch == 's' || *ch == 't' || *ch == 'a' || *ch == 'l') {
        4:   47-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4:   47-block  1
branch  2 taken 3 (fallthrough)
branch  3 taken 1
        3:   47-block  2
branch  4 taken 3 (fallthrough)
branch  5 taken 0
        3:   47-block  3
branch  6 taken 3 (fallthrough)
branch  7 taken 0
        3:   47-block  4
branch  8 taken 0 (fallthrough)
branch  9 taken 3
        1:   48:    if (*ch == 'c') {
        1:   48-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:   49:      strcpy(currstr[*parseidx].func, "cos");
    #####:   50:      currstr[*parseidx].lenth = 3;
    #####:   51:      ch += 3;
    %%%%%:   51-block  0
        1:   52:    } else if (*ch == 't') {
        1:   52-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:   53:      strcpy(currstr[*parseidx].func, "tan");
    #####:   54:      currstr[*parseidx].lenth = 3;
    #####:   55:      ch += 3;
    %%%%%:   55-block  0
        1:   56:    } else if (*(ch + 1) == 'i') {
        1:   56-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:   57:      strcpy(currstr[*parseidx].func, "sin");
        1:   58:      currstr[*parseidx].lenth = 3;
        1:   59:      ch = ch + 3;
        1:   59-block  0
        -:   60:      //   ch += 3;
    #####:   61:    } else if (*(ch + 1) == 'c') {
    %%%%%:   61-block  0
branch  0 never executed
branch  1 never executed
    #####:   62:      strcpy(currstr[*parseidx].func, "acos");
    #####:   63:      currstr[*parseidx].lenth = 4;
    #####:   64:      ch += 4;
    %%%%%:   64-block  0
    #####:   65:    } else if (*(ch + 1) == 's') {
    %%%%%:   65-block  0
branch  0 never executed
branch  1 never executed
    #####:   66:      strcpy(currstr[*parseidx].func, "asin");
    #####:   67:      currstr[*parseidx].lenth = 3;
    #####:   68:      ch += 3;
    %%%%%:   68-block  0
    #####:   69:    } else if (*(ch + 1) == 't') {
    %%%%%:   69-block  0
branch  0 never executed
branch  1 never executed
    #####:   70:      strcpy(currstr[*parseidx].func, "atan");
    #####:   71:      currstr[*parseidx].lenth = 3;
    #####:   72:      ch += 3;
    %%%%%:   72-block  0
    #####:   73:    } else if (*(ch + 1) == 'q') {
    %%%%%:   73-block  0
branch  0 never executed
branch  1 never executed
    #####:   74:      strcpy(currstr[*parseidx].func, "sqrt");
    #####:   75:      currstr[*parseidx].lenth = 3;
    #####:   76:      ch += 3;
    %%%%%:   76-block  0
    #####:   77:    } else if (*(ch + 1) == 'n') {
    %%%%%:   77-block  0
branch  0 never executed
branch  1 never executed
    #####:   78:      strcpy(currstr[*parseidx].func, "ln");
    #####:   79:      currstr[*parseidx].lenth = 2;
    #####:   80:      ch += 2;
    %%%%%:   80-block  0
    #####:   81:    } else if (*ch == 'l' && *(ch + 1) == 'o') {
    %%%%%:   81-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:   81-block  1
branch  2 never executed
branch  3 never executed
    #####:   82:      strcpy(currstr[*parseidx].func, "log");
    #####:   83:      currstr[*parseidx].lenth = 3;
    #####:   84:      ch += 3;
    %%%%%:   84-block  0
        -:   85:    }
        1:   86:    *stringParseindex += currstr[*parseidx].lenth;
        1:   87:    ++*parseidx;
        1:   88:    return 1;
        1:   88-block  0
        -:   89:  }
        3:   90:  return 0;
        3:   90-block  0
        -:   91:}
function isOperator called 5 returned 100% blocks executed 100%
        5:   92:int isOperator(char* ch, parseData* currstr, int* parseidx, int * stringParseindex) {
        5:   93:  if(*ch == '\000') {
        5:   93-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 4
        1:   94:    return 0;
        1:   94-block  0
        -:   95:  }
        4:   96:  currstr[*parseidx].lenth = 0;
        4:   97:  if (*ch == '+' || *ch == '-' || *ch == '*' || *ch == '/' || *ch == '^' ||
        4:   97-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 1
        3:   97-block  1
branch  2 taken 3 (fallthrough)
branch  3 taken 0
        3:   97-block  2
branch  4 taken 3 (fallthrough)
branch  5 taken 0
        3:   97-block  3
branch  6 taken 3 (fallthrough)
branch  7 taken 0
        3:   97-block  4
branch  8 taken 3 (fallthrough)
branch  9 taken 0
        3:   98:      *ch == '~' || *ch == '(' || *ch == ')') {
        3:   98-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3:   98-block  1
branch  2 taken 2 (fallthrough)
branch  3 taken 1
        2:   98-block  2
branch  4 taken 1 (fallthrough)
branch  5 taken 1
        3:   99:    currstr[*parseidx].operator= * ch;
        3:  100:    currstr[*parseidx].type = 3;
        3:  101:    ch = ch + 1;
        3:  102:    currstr[*parseidx].lenth++;
        3:  103:    *stringParseindex += currstr[*parseidx].lenth;
        3:  104:    ++*parseidx;
        3:  105:    return 1;
        3:  105-block  0
        -:  106:  }
        1:  107:  return 0;
        1:  107-block  0
        -:  108:}
function parser called 1 returned 100% blocks executed 100%
        1:  109:parseData* parser(char* str, int* stringParseindex) {
        1:  110:  *stringParseindex = 0;
        -:  111:
        -:  112:  // char * str1 = (char*)malloc(strlen(str) * sizeof(char));
        -:  113:  //  strcpy(str1,str);
        1:  114:  parseData* data = malloc(100 * sizeof(parseData));
        1:  115:  int parseidx = 0;
        6:  116:  while ((long unsigned int)*stringParseindex < strlen(str)) {
        1:  116-block  0
        6:  116-block  1
branch  0 taken 5
branch  1 taken 1 (fallthrough)
        5:  117:    isDigit((str + *stringParseindex), data, &parseidx, stringParseindex);
        5:  117-block  0
call    0 returned 5
        5:  118:    isOperator((str + *stringParseindex), data, &parseidx, stringParseindex);
call    0 returned 5
        5:  119:    isFunction((str + *stringParseindex), data, &parseidx, stringParseindex);
call    0 returned 5
        -:  120:  }
        1:  121:  return data;
        1:  121-block  0
        -:  122:}
        -:  123:
        -:  124:
        -:  125://           {'(', 0},
        -:  126://           {'+', 1},
        -:  127://           {'-', 1},
        -:  128://           {'*', 2},
        -:  129://           {'/', 2},
        -:  130://           {'^', 3},
        -:  131://           {'~', 4}	//	Унарный минус
        -:  132:
